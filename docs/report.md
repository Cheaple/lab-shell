### Have you met all the specifications outlined for the lab?
Yes, we have met all the specfications that were outlined in the lab document. We haved ensured this by testing in two different ways, both of which were suggested in the lab documentation. The manual test were helpful for testing basic functionality whilst the automated tests were helpful for testing more complex functionality. Top was also quite useful for making sure the sleep and zombie parts of the shell worked correctly.

### In which order?
They were implemented in a bit of sporadic order since we split the workload on different subtasks, Junqing is mainly responsible for the Piping and I/O redirection parts, Victor is mainly responsible for the Basis Commands, Built-in Commands and Ctrl-C, while Yule is mainly responsible for the remaining parts. This however resulted in some minor problems where it at times was difficult to test the functionality of the code, since it was not fully implemented. This was however not a big problem since we could just test the code in the next step of the implementation. This also unfortunely resulted in the code being messier than necessary, since one neccesarily didn't know what the other person was working on, or if moving some lines around would result in their implementation not working as intended. However this also comes with th upside that we also got to learn a lot about the different parts of the lab, since we had to understand the code that the other person had written and their own solutions. With the added benefit that the separate parts big completed faster than if all of us were working on it together. Since a lot of the different parts of the lab in some part affected the other parts, there was a clear need to understand all of the code written.

## What challenges did you encounter in meeting each specification?

1. Basic Commands: we fork a child process to call the `execvp()` function to run basic Unix commands like `ls`, `echo` and `grep`.

2. Background Execution: By default, a child process will execute in the background, unless the foreground lsh process waits for it to finish. According to the Lab specification, it is not required to print messages when a background process gets done, so we need not store any information about background processes, hence the simplicity of background execution implementation.

3. Piping: The most difficult part throughout the whole lab. It involves comprehensive understanding about a series of usage in system calls like `dup2()` and `pipe()`, the meticulous management of file descriptor in inter-process communication, and the construction of the execution stream. The following challenges has impressed us a lot:
    - Multiple process state framework makes the execution stream constrction much easier. When we firstly tried to establish communication pipe between different command, we want to create a linked list of pipes in advance and link them to the end of process. During this time, we are confused why the cmd_list stores the commands in the reverse order. Seemingly it only induces a lot of inconvenience when constructing linked list of pipes. Finally we realized that we needn't represent every existing pipes explicitly, or construct the pipe in the order of execution. The process will wait for input and get bllocked, so the order of execution or pipe constrction is out of importance. 
    - File descriptor of pipe is just a label, and can be forgotten immediately after being assigned to corresponding processes. At first we want to store all the details about the whole execution stream, then intensively manage the pipes but not iteratively. After this lab we understand the pipe has been encapsulated efficiently. We needn't care about how to maintain and destroy them, the OS will take these responsibilites automatically. So we can immediately use `pipe()` to generate new file descriptors to represent new pipe, and needn't care about the lost information of former pipes.
    - So you can see the current iterative execution algorithm in a relatively simple and efficient style.

<br>

4. I/O Redirection: I/O redirection is quite trivial compared with the management of file descriptor in piping. When there is only a single command, we just need to open the destination or departure file. However, for a complex commands consisting multiple single commands, we should redirect the input only for the first commmand and the output only for the last command. We use `dup2()` to manage file descriptor to redirect I/O, just like what we did in Piping.

5. Built-ins: The built-ins were overall quite easy to implement since they just required to call the built-in functions. The only tricky thing about them was that they are not called by creating a child process, so they have to be implemented a bit differently than the other commands. Another thing to take into account is how they are suppoused to handle different errand the file descriptor of pipe can be forgotten immediately after assigning it to corresponding processors. ors. For example, if the user tries to call the built in `cd` command with no arguments, it should print an error message. Overall these were quite easy to implement. A possble improvement for cleaning up the code for built in commands in fututre would be to store all the possible comamnds in an array and then just compare the input with the array, instead of having a bunch of if statements. That would make the code a lot cleaner, but for just having two built in commands, it was not deemed neccesary.

6. Ctrl-C Handling: The most difficult part with implementing Ctrl-C handling was using the old version of the python script for testing, which resulted in failed tests while they seemed to perform as expected when manual testing. As one might guess this was easily solved by using the updated versions of the tests, which we unfortunely weren't aware about until we had already spent some time trying to figure out what was wrong. The actual implementation of the Ctrl-C handling was quite easy since it was just a matter of setting a `SIGINT` handler for the lsh process. Actually, a child process does not inherit signal handlers from its parent, so the `SIGINT` will kill all foreground process except the parent lsh process as expected. One noticable challenge is to prevent background processes from getting killed by Ctrl-C; we call `setpgid()` to assign a different process group for each background process, which prevents them from receiving `SIGINT` and exiting.

7. No Zombies: Zombies collecting is relatively trivial. We use `signal()` function to set a handler function `handleSIGCHLD()` for the `SIGCHLD` signal caused by the termination of any child process; whenever a child process have terminated, its parent process will call the handler, in which `waitpid()` function will be called to collect the zombie child process.


### Do you have any feedback for improving the lab materials?
The lab materials were overall quite good, but there were some minor things that could be improved. For example, the lab document could have been a bit more clear about how the different parts of the lab were supposed to be implemented. For example, it was not clear that the built in commands were not supposed to be implemented by creating a child process. This was not a big problem, but it would have been nice to have it stated in the lab document. Another thing that could be improved is the test script. It was a bit unfortunate to spend time diagnosing a problem that only existed in the test script, whilst actually the code performed as intended. So for the next iteration of the lab, it would be nice if the test script was also updated. Overall the lab materials were really good, and it was a fun lab to work on. A big ask would for future iterations of the course would be if it was officially supported on Windows, as it was possible using WSL but it was a bit of a hassle to set up.